final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day for the border (low temperature)
    color borderColor;
    if (low <= 10) {
      borderColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(low, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (low <= 15) {
      borderColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(low, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (low <= 20) {
      borderColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(low, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (low <= 25) {
      borderColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(low, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (low <= 30) {
      borderColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(low, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      borderColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(low, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(1.25);
  fill(borderColor, 191); // 75% opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}


final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day for the border
    color borderColor;
    if (high <= 10) {
      borderColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      borderColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      borderColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      borderColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      borderColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      borderColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(1.25);
  fill(borderColor, 191); // 75% opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}


final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Determine the season and assign a color to the border based on average temperature of the season
    color borderColor;
    int month = PApplet.parseInt(date.substring(5, 7));
    if (month == 12 || month == 1 || month == 2) {
      borderColor = lerpColor(color(0, 100, 0), color(132, 185, 67), map(avg, 20, 35, 0, 1)); // Green for summer
    } else if (month >= 3 && month <= 5) {
      borderColor = lerpColor(color(139, 0, 0), color(217, 38, 41), map(avg, 15, 25, 0, 1)); // Red for autumn
    } else if (month >= 6 && month <= 8) {
      borderColor = lerpColor(color(0, 0, 139), color(0, 88, 157), map(avg, 5, 15, 0, 1)); // Blue for winter
    } else {
      borderColor = lerpColor(color(255, 140, 0), color(249, 193, 17), map(avg, 10, 25, 0, 1)); // Yellow-Orange for spring
    }

    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(1.25);
  fill(borderColor, 191); // 75% opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Determine the season and assign a color to the border based on average temperature of the season
    color borderColor;
    int month = PApplet.parseInt(date.substring(5, 7));
    if (month == 12 || month == 1 || month == 2) {
      borderColor = lerpColor(color(0, 128, 0), color(0, 255, 0), map(avg, 20, 35, 0, 1)); // Green for summer
    } else if (month >= 3 && month <= 5) {
      borderColor = lerpColor(color(128, 0, 0), color(255, 0, 0), map(avg, 15, 25, 0, 1)); // Red for autumn
    } else if (month >= 6 && month <= 8) {
      borderColor = lerpColor(color(0, 0, 128), color(0, 0, 255), map(avg, 5, 15, 0, 1)); // Blue for winter
    } else {
      borderColor = lerpColor(color(255, 165, 0), color(255, 255, 0), map(avg, 10, 25, 0, 1)); // Yellow-Orange for spring
    }

    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(1.25);
  fill(borderColor, 191); // 75% opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Determine the season and assign a color to the border based on average temperature of the season
    color borderColor;
    int month = PApplet.parseInt(date.substring(5, 7));
    if (month == 12 || month == 1 || month == 2) {
      borderColor = lerpColor(color(0, 255, 0), color(0, 100, 0), map(avg, 20, 35, 0, 1)); // Green for summer
    } else if (month >= 3 && month <= 5) {
      borderColor = lerpColor(color(255, 0, 0), color(100, 0, 0), map(avg, 15, 25, 0, 1)); // Red for autumn
    } else if (month >= 6 && month <= 8) {
      borderColor = lerpColor(color(0, 0, 255), color(0, 0, 100), map(avg, 5, 15, 0, 1)); // Blue for winter
    } else {
      borderColor = lerpColor(color(255, 255, 0), color(255, 165, 0), map(avg, 10, 25, 0, 1)); // Yellow-Orange for spring
    }

    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(1.5);
  fill(borderColor, 191); // 75% opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}

final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Determine the season and assign a color to the border based on average temperature of the season
    color borderColor;
    int month = PApplet.parseInt(date.substring(5, 7));
    if (month == 12 || month == 1 || month == 2) {
      borderColor = lerpColor(color(255, 100, 100), color(255, 0, 0), map(avg, 20, 35, 0, 1)); // Red for summer
    } else if (month >= 3 && month <= 5) {
      borderColor = lerpColor(color(255, 200, 100), color(255, 165, 0), map(avg, 15, 25, 0, 1)); // Orange for autumn
    } else if (month >= 6 && month <= 8) {
      borderColor = lerpColor(color(100, 100, 255), color(0, 0, 255), map(avg, 5, 15, 0, 1)); // Blue for winter
    } else {
      borderColor = lerpColor(color(100, 255, 100), color(0, 255, 0), map(avg, 10, 25, 0, 1)); // Green for spring
    }

    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(1.5);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Determine the season and assign a color to the border based on average temperature of the season
    color borderColor;
    int month = PApplet.parseInt(date.substring(5, 7));
    if (month == 12 || month == 1 || month == 2) {
      borderColor = lerpColor(color(255, 100, 100), color(255, 0, 0), map(avg, 20, 35, 0, 1)); // Red for summer
    } else if (month >= 3 && month <= 5) {
      borderColor = lerpColor(color(255, 200, 100), color(255, 165, 0), map(avg, 15, 25, 0, 1)); // Orange for autumn
    } else if (month >= 6 && month <= 8) {
      borderColor = lerpColor(color(100, 100, 255), color(0, 0, 255), map(avg, 5, 15, 0, 1)); // Blue for winter
    } else {
      borderColor = lerpColor(color(100, 255, 100), color(0, 255, 0), map(avg, 10, 25, 0, 1)); // Green for spring
    }

    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}


final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Determine the season and assign a color to the border
    color borderColor;
    int month = PApplet.parseInt(date.substring(5, 7));
    if (month == 12 || month == 1 || month == 2) {
      borderColor = color(255, 0, 0); // Red for summer
    } else if (month >= 3 && month <= 5) {
      borderColor = color(255, 165, 0); // Orange for autumn
    } else if (month >= 6 && month <= 8) {
      borderColor = color(0, 0, 255); // Blue for winter
    } else {
      borderColor = color(0, 255, 0); // Green for spring
    }

    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}

final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Determine the season and assign a pastel color to the border
    color borderColor;
    int month = PApplet.parseInt(date.substring(5, 7));
    if (month == 12 || month == 1 || month == 2) {
      borderColor = color(173, 216, 230); // Pastel blue for winter
    } else if (month >= 3 && month <= 5) {
      borderColor = color(144, 238, 144); // Pastel green for spring
    } else if (month >= 6 && month <= 8) {
      borderColor = color(255, 182, 193); // Pastel red for summer
    } else {
      borderColor = color(255, 228, 181); // Pastel orange for autumn
    }

    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}


final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(173, 216, 230), color(0, 0, 255), map(low, 0, 25, 0, 1)); // Light Blue to Bright Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}


final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(173, 216, 230), color(0, 0, 255), map(low, 0, 25, 0, 1)); // Light Blue to Bright Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 15, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 15, 17.5, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 17.5, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 22.5, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 22.5, 25, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 25, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}


final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(173, 216, 230), color(0, 0, 255), map(low, 0, 25, 0, 1)); // Light Blue to Bright Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 8) {
      centerColor = lerpColor(color(72, 61, 139), color(0, 0, 139), map(high, -6, 8, 0, 1)); // Teal to Dark Blue for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(0, 206, 209), color(0, 255, 255), map(high, 8, 15, 0, 1)); // Aqua to Lagoon for low temperatures
    } else if (high <= 19) {
      centerColor = lerpColor(color(60, 179, 113), color(34, 139, 34), map(high, 15, 19, 0, 1)); // Soft Fern to Foliage for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(85, 107, 47), color(154, 205, 50), map(high, 19, 25, 0, 1)); // Sage to Citron for warm temperatures
    } else if (high <= 33) {
      centerColor = lerpColor(color(255, 215, 0), color(255, 165, 0), map(high, 25, 33, 0, 1)); // Goldenrod to Dandelion for warmer temperatures
    } else if (high <= 37) {
      centerColor = lerpColor(color(255, 140, 0), color(255, 69, 0), map(high, 33, 37, 0, 1)); // Spice to Clementine for hot temperatures
    } else {
      centerColor = lerpColor(color(255, 0, 0), color(139, 0, 0), map(high, 37, 45, 0, 1)); // Crimson to Dark Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(173, 216, 230), color(0, 0, 255), map(low, 0, 25, 0, 1)); // Light Blue to Bright Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 100), color(0, 0, 255), map(low, 0, 25, 0, 1)); // Light Blue to Bright Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 50), color(0, 0, 255), map(low, 0, 25, 0, 1)); // Dark Blue to Bright Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 20), color(173, 216, 230), map(low, 0, 25, 0, 1)); // Dark Blue to Light Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i % rows;
    int col = i / rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(2);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(1);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}

final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 20), color(173, 216, 230), map(low, 0, 25, 0, 1)); // Dark Blue to Light Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i / columns;
    int col = i % columns;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other column for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(3);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(2);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i - PI / 6; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 20), color(173, 216, 230), map(low, 0, 25, 0, 1)); // Dark Blue to Light Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int row = i / columns;
    int col = i % columns;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other column for a hexagonal layout
    if (col % 2 == 1) {
      y += verticalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(3);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(2);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i - PI / 6; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}


final int hexSize = 25; // Radius of each hexagon
final int rows = 15; // Number of hexagons per column
final int columns = ceil(365.0 / rows); // Calculate number of columns to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = (int)(columns * (1.5 * hexSize)) + 100; // Calculate width dynamically based on columns
final int canvasHeight = 900; // Fixed canvas height

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 20), color(173, 216, 230), map(low, 0, 25, 0, 1)); // Dark Blue to Light Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int col = i / rows;
    int row = i % rows;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (row % 2 == 1) {
      x += horizontalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(3);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(2);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i - PI / 6; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}

final int hexSize = 25; // Radius of each hexagon
final int columns = 15; // Number of hexagons per row
final int rows = ceil(365.0 / columns); // Calculate number of rows to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = 900; // Fixed canvas width
final int canvasHeight = (int)(rows * (sqrt(3) * hexSize)) + 100; // Calculate height dynamically based on rows

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 20), color(173, 216, 230), map(low, 0, 25, 0, 1)); // Dark Blue to Light Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int col = i % columns;
    int row = i / columns;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (row % 2 == 1) {
      x += horizontalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(3);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(2);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i - PI / 6; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int columns = 15; // Number of hexagons per row
final int rows = ceil(365.0 / columns); // Calculate number of rows to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = 900; // Fixed canvas width
final int canvasHeight = (int)(rows * (sqrt(3) * hexSize)) + 100; // Calculate height dynamically based on rows

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 20), color(173, 216, 230), map(low, 0, 25, 0, 1)); // Dark Blue to Light Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int col = i % columns;
    int row = i / columns;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (row % 2 == 1) {
      x += horizontalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(3);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(2);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i - PI / 6; // Adjust angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}


final int hexSize = 25; // Radius of each hexagon
final int columns = 15; // Number of hexagons per row
final int rows = ceil(365.0 / columns); // Calculate number of rows to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = 900; // Fixed canvas width
final int canvasHeight = (int)(rows * (sqrt(3) * hexSize)) + 100; // Calculate height dynamically based on rows

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 20), color(173, 216, 230), map(low, 0, 25, 0, 1)); // Dark Blue to Light Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int col = i % columns;
    int row = i / columns;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (row % 2 == 1) {
      x += horizontalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(3);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(2);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i; // Adjusted angle for flat edge alignment
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}

final int hexSize = 25; // Radius of each hexagon
final int columns = 15; // Number of hexagons per row
final int rows = ceil(365.0 / columns); // Calculate number of rows to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = 900; // Fixed canvas width
final int canvasHeight = (int)(rows * (sqrt(3) * hexSize)) + 100; // Calculate height dynamically based on rows

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 20), color(173, 216, 230), map(low, 0, 25, 0, 1)); // Dark Blue to Light Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int col = i % columns;
    int row = i / columns;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (row % 2 == 1) {
      x += horizontalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(3);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly smaller)
  stroke(middleColor);
  strokeWeight(2);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.7); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.5); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = PI / 3 * i - PI / 6; // Adjust angle for flat edge at top
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
final int hexSize = 25; // Radius of each hexagon
final int columns = 15; // Number of hexagons per row
final int rows = ceil(365.0 / columns); // Calculate number of rows to fit all days

// Set up a larger canvas size to fit all hexagons properly
final int canvasWidth = 900; // Fixed canvas width
final int canvasHeight = (int)(rows * (sqrt(3) * hexSize)) + 100; // Calculate height dynamically based on rows

void settings() {
  size(canvasWidth, canvasHeight); // Set up the canvas size here, using settings()
}

void setup() {
  background(255); // Set the background color to white

  // Load the JSON file from the data folder
  JSONObject jsonData = loadJSONObject("sydney_temperature_2023.json");

  // Get the array of daily data
  JSONArray days = jsonData.getJSONArray("days");
  
  // Set up drawing parameters
  int xOffset = 40; // X-axis start offset
  int yOffset = 50; // Y-axis start offset
  float horizontalSpacing = hexSize * 1.5; // Adjusted for perfect tessellation
  float verticalSpacing = sqrt(3) * hexSize; // Vertical spacing for hexagons

  // Loop through the data and draw hexagons for each day
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i);
    String date = day.getString("datetime");
    float high = day.getFloat("tempmax");
    float low = day.getFloat("tempmin");
    float avg = (high + low) / 2.0; // Calculate the average temperature for the day (using 2.0 to ensure float division)

    // Map temperatures to gradient colors specific to each day
    color borderColor = lerpColor(color(0, 0, 20), color(173, 216, 230), map(low, 0, 25, 0, 1)); // Dark Blue to Light Blue for Border (Lowest Temperature)
    color middleColor = color(255); // Set the middle color to white for now (Average Temperature)
    color centerColor;
    if (high <= 10) {
      centerColor = lerpColor(color(148, 0, 211), color(75, 0, 130), map(high, 0, 10, 0, 1)); // Violet to Indigo for very low temperatures
    } else if (high <= 15) {
      centerColor = lerpColor(color(75, 0, 130), color(0, 0, 255), map(high, 10, 15, 0, 1)); // Indigo to Blue for low temperatures
    } else if (high <= 20) {
      centerColor = lerpColor(color(0, 0, 255), color(0, 255, 0), map(high, 15, 20, 0, 1)); // Blue to Green for moderate temperatures
    } else if (high <= 25) {
      centerColor = lerpColor(color(0, 255, 0), color(255, 255, 0), map(high, 20, 25, 0, 1)); // Green to Yellow for warm temperatures
    } else if (high <= 30) {
      centerColor = lerpColor(color(255, 255, 0), color(255, 127, 0), map(high, 25, 30, 0, 1)); // Yellow to Orange for warmer temperatures
    } else {
      centerColor = lerpColor(color(255, 127, 0), color(255, 0, 0), map(high, 30, 40, 0, 1)); // Orange to Red for very hot temperatures
    }

    // Calculate x and y positions for each hexagon
    int col = i % columns;
    int row = i / columns;
    float x = xOffset + col * horizontalSpacing;
    float y = yOffset + row * verticalSpacing;

    // Offset every other row for a hexagonal layout
    if (row % 2 == 1) {
      x += horizontalSpacing / 2;
    }

    // Draw the hexagon layers
    drawHexagon(x, y, hexSize, borderColor, middleColor, centerColor);
  }
}

void drawHexagon(float x, float y, float radius, color borderColor, color middleColor, color centerColor) {
  // Draw the border hexagon (Outer Layer)
  stroke(borderColor);
  strokeWeight(3);
  fill(borderColor, 180); // Slight opacity for the border color
  drawSingleHexagon(x, y, radius);

  // Draw the middle hexagon (Middle Layer, slightly larger)
  stroke(middleColor);
  strokeWeight(2);
  fill(middleColor);
  drawSingleHexagon(x, y, radius * 0.6); // Middle layer smaller to make center more prominent

  // Draw the center hexagon (Inner Layer, larger)
  stroke(centerColor);
  strokeWeight(1);
  fill(centerColor, 200); // Slight opacity for the center color
  drawSingleHexagon(x, y, radius * 0.8); // Larger center for emphasis on highest temperature
}

void drawSingleHexagon(float x, float y, float radius) {
  beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = TWO_PI / 6 * i;
    float xOffset = cos(angle) * radius;
    float yOffset = sin(angle) * radius;
    vertex(x + xOffset, y + yOffset);
  }
  endShape(CLOSE);
}
