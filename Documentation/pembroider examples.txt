pembroider examples

// Test program for the PEmbroider library for Processing:
// Lines and curves

import processing.embroider.*;
PEmbroiderGraphics E;


void setup() {
  noLoop(); 
  size (1075, 700);

  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("Pembroider_lines_1.vp3");
  E.setPath(outputFilePath); 

  E.beginDraw(); 
  E.clear();
  E.noFill(); 
  
 
  //-----------------------
  // Vary stroke weight, 
  // show both PERPENDICULAR & TANGENT
  int nLines = 15; 
  int lineLength = 150;
  
  E.strokeSpacing(2.0);
  E.setStitch(5, 15, 0.0);
  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.33;
  
  E.strokeCap(SQUARE); // NOTE: currently not working for PERPENDICULAR
  E.strokeMode(PEmbroiderGraphics.PERPENDICULAR); 
  
  //repeats a stitch at the end of each line drawn
  E.beginRepeatEnd(2);
  
  int lineX = 50;
  for (int i=0; i<nLines; i++) {
    float x0 = lineX; 
    float x1 = x0+lineLength;
    float y0 = map(i, 0, nLines-1, 50, height-50);
    E.strokeWeight(i+1); 
    E.line (x0, y0, x1, y0);
  }
  
  
  E.strokeCap(SQUARE);
  lineX += lineLength+50;
  E.strokeMode(PEmbroiderGraphics.TANGENT); 
  for (int i=0; i<nLines; i++) {
    float x0 = lineX; 
    float x1 = x0+lineLength;
    float y0 = map(i, 0, nLines-1, 50, height-50);
    E.strokeWeight(i+1); 
    E.line (x0, y0, x1, y0);
  }
  


  //-----------------------
  // Vary the stitch lengh
  
  E.strokeMode(PEmbroiderGraphics.TANGENT);
  E.strokeWeight(1); 
  
  lineX += lineLength+50;
  for (int i=0; i<nLines; i++) {
    float x0 = lineX; 
    float x1 = x0+lineLength;
    float y0 = map(i, 0, nLines-1, 50, height-50);
    float stitchLen = (x1-x0)/(nLines-i);
    E.setStitch(5, stitchLen, 0.0);
    E.line (x0, y0, x1, y0);
  }
  

  //-----------------------
  // Vary the strokeSpacing, 
  // show both PERPENDICULAR & TANGENT
  E.strokeCap(ROUND);
  E.strokeWeight(15); 
  E.setStitch(5, 15, 0.0);
  E.strokeMode(PEmbroiderGraphics.PERPENDICULAR); 
  
  lineX += lineLength+50;
  for (int i=0; i<nLines; i++) {
    float x0 = lineX; 
    float x1 = x0+lineLength;
    float y0 = map(i, 0, nLines-1, 50, height-50);
    E.strokeSpacing(1.0 + i);
    E.line (x0, y0, x1, y0);
  }
  
  
  E.strokeCap(ROUND);
  E.strokeWeight(15); 
  E.setStitch(5, 15, 0.0);
  E.strokeMode(PEmbroiderGraphics.TANGENT);
  lineX += lineLength+50;
  for (int i=0; i<nLines; i++) {
    float x0 = lineX; 
    float x1 = x0+lineLength;
    float y0 = map(i, 0, nLines-1, 50, height-50);
    E.strokeSpacing(1.0 + i);
    E.line (x0, y0, x1, y0);
  }

  E.endRepeatEnd();

  //-----------------------
  //E.optimize(); // slow, but very good and important
  E.visualize();
  //E.endDraw(); // write out the file
  //save("Pembroider_lines_1.png");
}

// Test program for the PEmbroider library for Processing:
// Lines and curves

import processing.embroider.*;
PEmbroiderGraphics E;


void setup() {
  noLoop(); 
  size (800, 600);

  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("PEmbroider_lines_1.vp3");
  E.setPath(outputFilePath);
}

void draw() {
  background(220); 
  E.beginDraw(); 
  E.clear();
  E.noFill(); 
  
  
  //-----------------------
  E.strokeWeight(1); 
  E.ellipseMode(CENTER);
  for (int i=0; i<6; i++){
    float cx = map(i,0,5, 100,width-100);
    float cy = 100; 
    float minStitchLen = map(i,0,5, 5, 40);
    E.setStitch(minStitchLen, 20, 0.0);
    E.circle(cx,cy, 100); 
  }
  
  

  //-----------------------
  E.strokeWeight(1); 
  E.setStitch(10, 40, 0.0);

  E.beginShape(); 
  float cx = 125; 
  float cy = 400;
  float r = 40;
  for (int i=0; i<=360; i++) {
    float t = map(i, 0, 360, 0, TWO_PI);
    float x = cx + r*sin(t) + (r*1.33)*cos(2*t); 
    float y = cy + r*cos(t) + (r*1.33)*sin(2*t); 
    E.vertex (x, y);
  }
  E.endShape();
  
  
  //-----------------------
  E.setStitch(4, 20, 0.0);
  E.beginShape();
  float px = 550;
  float py = 400; 
  float t = 0; 
  float rr = 0.25;
  for (int i=0; i<150; i++) {
    t += 10.0; 
    E.vertex(px,py);
    px += i*rr*sin(radians(t)); 
    py += i*rr*cos(radians(t)); 
  }
  E.endShape();
  
  
  //E.strokeSpacing(2.0);
  //E.strokeMode(PEmbroiderGraphics.PERPENDICULAR); 

  //-----------------------
  // E.optimize(); // slow, but very good and important
  E.visualize();
  // E.endDraw(); // write out the file
  // save("Pembroider_lines_2.png");  //saves a png of design from canvas
}

// Test program for the PEmbroider library for Processing:
// Basic shapes

import processing.embroider.*;
PEmbroiderGraphics E;


void setup() {
  //noLoop(); 
  size (900, 600);

  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("PEmbroider_shapes.vp3");
  E.setPath(outputFilePath); 

  E.ellipseMode(CORNER);

  E.beginDraw(); 
  E.clear();
  E.strokeWeight(1); 
  E.fill(0, 0, 0); 
  E.noStroke(); 

  E.hatchSpacing(5);
  E.hatchAngleDeg(50);
  E.hatchMode(PEmbroiderGraphics.SATIN);
  E.setStitch(2, 50, 0); 
  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.33;

  //-----------------------
  // Standard shapes are supported
  E.circle (50, 50, 150);
  E.square(225, 50, 150); 
  E.rect (400, 50, 100, 150);
  E.rect (525, 50, 150, 150, 25); 
  E.rect (700, 50, 150, 150, 0, 0, 0, 50); 
  
  
  E.quad (50, 250, 200, 250, 170, 400, 50, 400);
  E.ellipse(210, 250, 200, 150);
  E.triangle (410, 400, 460, 250, 510, 400); 
  E.arc (525, 250, 150, 150, 0, PI*1.25, PIE); 
  E.arc (700, 250, 150, 150, 0, PI*1.25, CHORD); 

  //-----------------------
  // Arbitrary polygons are supported
  E.beginShape();
  E.vertex(50, 450);
  E.vertex(50, 575);
  E.vertex( 330, 575);
  E.vertex( 330, 500);
  E.vertex(200, 500);
  E.vertex(175, 425);

  E.endShape(CLOSE);

  //-----------------------
  // Shapes can mix straight and curved sides
  E.beginShape();
  E.vertex(365, 475);
  E.quadraticVertex(530, 430, 450, 500);
  E.quadraticVertex(400, 530, 560, 575);
  E.vertex(560, 430);
  E.vertex(360, 430);
  E.endShape(CLOSE);

  //-----------------------
  // Shapes can be "compound" and include holes, 
  // i.e. have multiple contours
  E.beginShape();
  E.vertex(600, 460);
  E.vertex(850, 430);
  E.vertex(800, 575);
  E.vertex(620, 575);
  
  E.beginContour();
  E.vertex(650, 520);
  E.vertex(710, 520);
  E.vertex(735, 505);
  E.vertex(690, 475);
  
  E.vertex(643, 475);
  
  
  
  
  E.endContour();
  
  E.endShape(CLOSE);


  //-----------------------
  //E.optimize(); // slow, but very good and very important
  //E.visualize();
  //E.endDraw(); // write out the file
  //save("PEmbroider_shapes.png");
}

void draw(){
  background(200);
  if (mousePressed){
    E.eraser(mouseX,mouseY,20);
  }
  E.visualize();
}

// "Hello World" program for the PEmbroider library for Processing. 
// Generates a smily face and the words "hello world". 

// Import the library, and declare a PEmbroider renderer. 
import processing.embroider.*;
PEmbroiderGraphics E;

void setup() {
  size (600, 750);
  float cx = width/2; 
  float cy = height/2 - 40;

  // Create the PEmbroider object
  E = new PEmbroiderGraphics(this, width, height);

  // Start rendering to the PEmbroiderer.
  E.beginDraw(); 
  E.clear();
  E.ellipseMode(CENTER);  // Ellipses are specfied by their center (not top-left)
  E.CIRCLE_DETAIL = 60;   // Circles are secretly 60-sided polygons; good enough
  E.toggleResample(true); // Turn resampling on (good for embroidery machines)

  // Draw the face outline
  E.noFill();
  E.stroke(0, 0, 0);
  E.strokeWeight(30); 
  E.strokeSpacing(2.5);
  E.strokeMode(PEmbroiderGraphics.PERPENDICULAR);
  E.setStitch(10, 50, 0); 
  E.ellipse (cx, cy, 500, 500); 

  // Draw the eyes
  E.fill(0, 0, 0); 
  E.stroke(0, 0, 0); 
  E.strokeWeight(1); 
  E.setStitch(10, 25, 0);
  E.hatchSpacing(2); 
  E.hatchMode(PEmbroiderGraphics.CONCENTRIC);
  E.circle(cx - 90, cy - 50, 110); 
  E.circle(cx + 90, cy - 50, 110); 

  // Draw the mouth
  E.noFill(); 
  E.stroke(0, 0, 0); 
  E.strokeWeight(50); 
  //E.strokeSpacing(1.5);
  E.strokeMode(PEmbroiderGraphics.TANGENT);
  E.setStitch(10, 25, 0); 
  E.arc(cx, cy, 270, 270, PI*0.15, PI*0.85); 

  // Say hello
  E.stroke(0, 0, 0); 
  E.textSize(2.5); 
  E.textAlign(CENTER, BOTTOM);
  E.textFont(PEmbroiderFont.SCRIPT_SIMPLEX);
  E.text("Hello World!", cx, 675); 


  // May be helpful for .pes output
  /*
  PEmbroiderWriter.PES.TRUNCATED = false;
   PEmbroiderWriter.PES.VERSION = 1;
   PEmbroiderWriter.TITLE = "HELLWRLD"; // Note: 8 character limit!
   */

  //-----------------------
  // IMPORTANT: Un-comment both E.optimize() and E.endDraw() 
  // in order to actually export the embroidery file. 
  // Note that E.optimize() can take about a minute to run. Patience!

  E.optimize(); // VERY SLOW, but ESSENTIAL for good file output!
  E.visualize(true, false, true); // Display (preview) the embroidery onscreen.
  String outputFilePath = sketchPath("Hello_PEmbroider.pes");
  E.setPath(outputFilePath);
  // E.endDraw(); // Uncomment this to write out the embroidery file.

  boolean bAlsoSaveScreenshot = false; 
  if (bAlsoSaveScreenshot) { // Save a screenshot 
    save("Hello_Pembroider.png");
  }
}


void draw() {
  boolean bShowAnimatedProgress = false;
  if (bShowAnimatedProgress) {
    background(255);
    E.visualize(true, false, true, frameCount);
  }
}


// Test program for the PEmbroider library for Processing:
// Set the orientation of stitches (the hatchAngle) automatically, 
// based on the orientation of a shape, using hatchAngle(E.AUTO).

import processing.embroider.*;
PEmbroiderGraphics E;

//------------------------------------------------
void setup() {
  size(500, 500);

  E = new PEmbroiderGraphics(this);
  E.noStroke();
  E.fill(0);
  E.hatchSpacing(8);
  E.hatchAngle(E.AUTO);
}

//------------------------------------------------
void draw() {
  background(255);
  
  E.clear();
  E.hatchMode(mousePressed ? E.PARALLEL : E.SATIN);
  
  E.beginShape(); 
  {
    E.vertex(100, 100); 
    E.vertex(160, 110); 
    E.vertex(250, 150); 
    E.vertex((300+mouseX)/2, (200+mouseY)/2); 
    E.vertex(mouseX, mouseY);
    E.vertex((250+mouseX)/2, (300+mouseY)/2);
    E.vertex(150, 250);
  }
  E.endShape(CLOSE);
  
  E.visualize();
}

// Test program for the PEmbroider library for Processing:
// Testing SATIN hatching, with Theodore Gray's shape from 
// http://home.theodoregray.com/stitchblog/2015/7/10/embroidered-animation-finally

import processing.embroider.*;
PEmbroiderGraphics E;

float shapeCoords[][] = {
  {579, 51}, {712, 59}, {716, 182}, {744, 300}, {748, 345}, 
  {749, 389}, {732, 470}, {716, 510}, {692, 551}, {648, 618}, 
  {585, 670}, {471, 699}, {372, 729}, {282, 711}, {169, 643}, 
  {88, 562}, {50, 226}, {120, 159}, {252, 183}, {244, 350}, 
  {137, 234}, {137, 350}, {323, 487}, {293, 103}, {365, 78}, 
  {508, 459}, {496, 279}, {575, 276}, {665, 382}, {628, 119}, 
  {598, 228}, {474, 154}};

//-----------------------------------------------------
void setup() {
  noLoop(); 
  size (800, 800);

  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("PEmbroider_satin_hatching_1.vp3");
  E.setPath(outputFilePath); 

  E.beginDraw(); 
  E.clear();

  // E.satinMode(E.ZIGZAG); // Original style
  // E.satinMode(E.SIGSAG); // Zigzag parallelized
  E.satinMode(E.BOUSTROPHEDON); // The new mode, back-and-forth!
  E.SATIN_RESAMPLING_OFFSET_FACTOR=0.2;

  E.noStroke(); 
  E.fill(0, 0, 0); 
  E.hatchSpacing(1.66);
  E.hatchAngleDeg(45);
  E.hatchMode(E.SATIN);
  E.setStitch(10, 60, 0); 
  

  E.beginShape();
  for (int i=0; i<shapeCoords.length; i++) {
    float px = shapeCoords[i][0];
    float py = shapeCoords[i][1];
    E.vertex(px, py);
  }
  E.endShape(CLOSE);
  
  //E.optimize(); // slow, but very important for file output!
  E.visualize(true, true, true);
  //E.endDraw(); // write out the file
  //save("PEmbroider_satin_hatching_1.png");
}

// Test program for the PEmbroider library for Processing:
// SATIN hatching, interactive demo

import processing.embroider.*;
PEmbroiderGraphics E;

//-----------------------------------------------------
void setup() {
  // noLoop(); 
  size (900, 600);

  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("PEmbroider_satin_hatching_2.vp3");
  E.setPath(outputFilePath);
}

//-----------------------------------------------------
void draw() {
  background(200); 

  E.beginDraw(); 
  E.clear();

  E.strokeWeight(1); 
  E.fill(0, 0, 0); 

  E.hatchSpacing(6);
  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.5;
  E.hatchAngleDeg(mouseX/10.0);
  E.hatchMode(PEmbroiderGraphics.SATIN);
  E.setStitch(10, 50, 0); 


  E.beginShape();
  E.vertex(100, 100); 
  E.vertex(160, 110); 
  E.vertex(250, 170);
  E.vertex(300, 250);
  E.vertex(330, 290); 
  E.vertex(270, 295);
  E.vertex(150, 180); 
  E.endShape(CLOSE);

  //-----------------------
  // Shapes can mix straight and curved sides
  E.beginShape();
  E.vertex(365, 175);
  E.quadraticVertex(530, 130, 450, 200);
  E.quadraticVertex(400, 230, 560, 275);
  E.vertex(560, 130);
  E.vertex(360, 130);
  E.endShape(CLOSE);


  //-----------------------
  // Shapes can be "compound" and include holes, 
  // i.e. have multiple contours
  E.beginShape();
  E.vertex(600, 160);
  E.vertex(850, 130);
  E.vertex(800, 275);
  E.vertex(620, 275);

  E.beginContour();
  E.vertex(650, 220);
  E.vertex(710, 220);
  E.vertex(735, 205);
  E.vertex(690, 175);
  E.vertex(643, 175);
  E.endContour();

  E.endShape(CLOSE);

  //-----------------------
  E.optimize(); // slow, but very good and very important
  E.visualize(true, true, true);
}

void keyPressed() {
  if ((key == 's') || (key == 'S')) {
    E.endDraw();
  }
}

// Test program for the PEmbroider library for Processing:
// Different methods for overlapping shapes with PEmbroider

import processing.embroider.*;
PEmbroiderGraphics E;

void setup() {
  noLoop(); 
  size (1250, 575);
  
  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("PEmbroider_shape_culling.vp3");
  E.setPath(outputFilePath);
 
  E.beginDraw(); 
  E.clear();
  E.fill(0, 0, 0); 
  
  E.CULL_SPACING = 7;
  E.hatchSpacing(4);
  E.strokeWeight(1); 
  E.setStitch(5,20,0); 
 
  //-----------------------
  // Two overlapping circles, with PARALLEL hatch
  E.hatchMode(PEmbroiderGraphics.PARALLEL); 
  E.hatchAngleDeg(45); 
  E.circle( 150, 150, 250);
  E.hatchAngleDeg(90); 
  E.circle(275, 150, 250);

  // One circle culling another, with PARALLEL hatch
  E.hatchMode(PEmbroiderGraphics.PARALLEL);
  E.beginCull();
  E.hatchAngleDeg(45); 
  E.circle( 150, 425, 250);
  E.hatchAngleDeg(90); 
  E.circle(275, 425, 250);
  E.endCull();

  //-----------------------
  // Two overlapping circles, with CONCENTRIC hatch
  E.hatchMode(PEmbroiderGraphics.CONCENTRIC);
  E.hatchAngleDeg(45); 
  E.circle(550, 150, 250);
  E.hatchAngleDeg(90); 
  E.circle(675, 150, 250);

  // One circle culling another, with CONCENTRIC hatch
  E.hatchMode(PEmbroiderGraphics.CONCENTRIC);
  E.beginCull();
  E.hatchAngleDeg(45); 
  E.circle(550, 425, 250);
  E.hatchAngleDeg(90); 
  E.circle(675, 425, 250);
  E.endCull();
  
  //-----------------------
  // Occluding circles with mixed hatch modes
  E.hatchAngle(radians(90));
  
  E.hatchMode(PEmbroiderGraphics.CONCENTRIC);
  E.circle(950, 150, 250);
  E.HATCH_MODE = PEmbroiderGraphics.PARALLEL;
  E.circle(1100, 150, 250);
  
  E.beginCull();
  E.hatchMode(PEmbroiderGraphics.CONCENTRIC);
  E.circle(950, 425, 250);
  E.HATCH_MODE = PEmbroiderGraphics.PARALLEL;
  E.circle(1100, 425, 250);
  E.endCull();

  //-----------------------
  // E.optimize(); // slow but good and important
  E.visualize(); //true, true, true);
  // E.endDraw(); // write out the file
  //save("PEmbroider_shape_culling.png");
}


// Test program for the PEmbroider library for Processing:
// Different methods for filling (hatching) shapes with PEmbroider: 
// * PEmbroiderGraphics.PARALLEL
// * PEmbroiderGraphics.CONCENTRIC
// * PEmbroiderGraphics.SPIRAL


import processing.embroider.*;
import static processing.embroider.PEmbroiderGraphics.*; // PEmbroiderGraphics.PARALLEL -> PARALLEL

PEmbroiderGraphics E;

void setup() {
  noLoop(); 
  size (700, 700);
  E = new PEmbroiderGraphics(this, width, height);

  String outputFilePath = sketchPath("PEmbroider_shape_hatching_1.vp3");
  E.setPath(outputFilePath); 
  E.beginDraw(); 
  E.clear();
  E.strokeWeight(1); 
  E.fill(0, 0, 0); 
  E.noStroke(); 
  E.setStitch(3,40,0);
  
  //-----------------------
  //Shapes filled with PARALLEL hatch mode
  E.hatchMode(PARALLEL);
  E.hatchAngleDeg(45);
  E.hatchSpacing(4);
  E.circle( 125, 125, 200);

  E.hatchMode(PARALLEL);
  E.hatchAngle(radians(90));
  E.hatchSpacing(4);
  E.circle(350, 125, 200);

  E.hatchMode(PARALLEL);
  E.hatchAngle(radians(90));
  E.hatchSpacing(8);
  E.circle(575, 125, 200);


  //-----------------------
  //Shapes filled with CONCENTRIC hatch mode
  E.hatchMode(CONCENTRIC);
  E.hatchSpacing(3);
  E.circle( 125, 350, 200);
  
  E.hatchMode(CONCENTRIC);
  E.hatchSpacing(4);
  E.rect(250, 250, 200, 200);

  E.hatchMode(CONCENTRIC);
  E.hatchSpacing(8);
  E.rect (475, 250, 200, 200);


  //-----------------------
  //shapes filled with SPIRAL hatch mode
  
  //for SPIRAL 
  
  E.hatchMode(SPIRAL);
  E.hatchSpacing(15);
  E.circle( 125, 575, 200);

  E.hatchMode(SPIRAL);
  E.hatchSpacing(8);
  E.circle(350,575, 200);

  E.hatchMode(SPIRAL);
  E.hatchSpacing(8);
  E.rect(475, 475, 200, 200);
  
  //-----------------------
  //shapes filled with SATIN hatch mode
  E.hatchMode(SPIRAL);
  E.hatchSpacing(15);
  E.circle( 125, 575, 200);

  E.hatchMode(SPIRAL);
  E.hatchSpacing(8);
  E.circle(350,575, 200);

  E.hatchMode(SPIRAL);
  E.hatchSpacing(8);
  E.rect(475, 475, 200, 200);


  //-----------------------
  //E.optimize(); // slow but good and important
  E.visualize();
  //E.endDraw(); // write out the file
  //save("PEmbroider_shape_hatching_1.png");
}


//--------------------------------------------
void draw() {
  ;
}

// Test program for the PEmbroider library for Processing:
// Different methods for filling (hatching) shapes with PEmbroider: 
// * PEmbroiderGraphics.PERLIN
// * PEmbroiderGraphics.CROSS
// * PEmbroiderGraphics.DRUNK
// * PEmbroiderGraphics.VECFIELD

import processing.embroider.*;
PEmbroiderGraphics E;


void setup() {
  noLoop(); 
  size (700, 700);
  E = new PEmbroiderGraphics(this, width, height);

  String outputFilePath = sketchPath("PEmbroider_shape_hatching_2.vp3");
  E.setPath(outputFilePath); 
  E.beginDraw(); 
  E.clear();
  E.strokeWeight(1); 
  E.fill(0, 0, 0); 
  E.noStroke(); 


  //-----------------------
  E.HATCH_MODE = PEmbroiderGraphics.PERLIN;
  E.HATCH_SPACING = 4;
  E.HATCH_SCALE = 1.0;
  E.rect( 25, 25, 200, 200);

  E.HATCH_MODE = PEmbroiderGraphics.PERLIN;
  E.HATCH_SPACING = 8;
  E.HATCH_SCALE = 1.0;
  E.rect(250, 25, 200, 200);

  E.HATCH_MODE = PEmbroiderGraphics.PERLIN;
  E.HATCH_SPACING = 4;
  E.HATCH_SCALE = 4.5;
  E.rect(475, 25, 200, 200);


  //-----------------------
  // The "cross" hatch mode is a convenience mode, 
  // placing parallel lines of stitching at two orientations
  // specified by HATCH_ANGLE and HATCH_ANGLE2:
  E.HATCH_MODE = PEmbroiderGraphics.CROSS;
  E.HATCH_ANGLE = radians(90);
  E.HATCH_ANGLE2 = radians(0); 
  E.HATCH_SPACING = 4;
  E.circle(125, 350, 200);

  E.HATCH_MODE = PEmbroiderGraphics.CROSS;
  E.HATCH_ANGLE = radians(90); 
  E.HATCH_ANGLE2 = radians(75); 
  E.HATCH_SPACING = 8;
  E.circle(350, 350, 200);
  
  E.HATCH_MODE = PEmbroiderGraphics.PERLIN;
  E.HATCH_ANGLE = radians(90); 
  E.HATCH_ANGLE2 = radians(75); 
  E.HATCH_SPACING = 8;
  E.circle(575, 350, 200);


  /*
  // The purpose of the "drunk walk" hatch mode is 
  // not to be useful in itself -- but rather, it is 
  // a simple pedagogic example for how to code your
  // OWN hatch technique (in the PEmbroider source code), 
  // if you wanted to extend the PEmbroider library. 
  // This is commented out because in practice, the DRUNK 
  // hatch mode produces really bad snarls. Don't use it!
  //
  E.HATCH_MODE = PEmbroiderGraphics.DRUNK;
  E.circle(350, 200, 100);
  */
  

  //-----------------------
  // The VECFIELD hatch mode allows you to create a 
  // user-defined vector field, with a function that 
  // returns a 2D vector indicating the local orientation
  // of stitches at any given point (x,y). 
  // See the MyVecField class below.
  MyVecField mvf = new MyVecField();
  E.HATCH_MODE = PEmbroiderGraphics.VECFIELD;
  E.HATCH_VECFIELD = mvf;
  E.HATCH_SPACING = 4;
  E.ellipse ( 350, 575, 650, 200);


  //-----------------------
  //E.optimize(); // slow, but good and important
  E.visualize();
  //E.endDraw(); // write out the file
  //save("PEmbroider_shape_hatching_2.png");
}


//--------------------------------------------
class MyVecField implements PEmbroiderGraphics.VectorField {
  public PVector get(float x, float y) {
    x*=0.05;
    return new PVector(1, 0.5*sin(x));
  }
}


//--------------------------------------------
void draw() {
  ;
}

// Test program for the PEmbroider library for Processing:
// Different methods for filling (hatching) shapes with PEmbroider: 
// Experiments with E.PARALLEL_RESAMPLING_OFFSET_FACTOR and
// E.setStitch (with or without noise).


import processing.embroider.*;
PEmbroiderGraphics E;


void setup() {
  noLoop(); 
  size (700, 700);
  E = new PEmbroiderGraphics(this, width, height);

  String outputFilePath = sketchPath("PEmbroider_shape_hatching_3.vp3");
  E.setPath(outputFilePath); 
  E.beginDraw(); 
  E.clear();
  E.strokeWeight(1); 
  E.fill(0, 0, 0); 
  E.noStroke(); 
  //E.ellipseMode(CENTER); 


  // float msl = 5.0;   // minimum stitch length
  // float  sl = 10.0;  // desirable stitch length
  // float  rn = 1.0;   // resample noise -- to avoid alignment patterns
  // E.setStitch( msl, sl, rn);

  //-----------------------
  // Hatches have a stitch length of 50. 
  E.hatchMode(PEmbroiderGraphics.PARALLEL);
  E.hatchAngleDeg(20.0); 
  E.hatchSpacing(2.0); 
  E.setStitch( 5, 50, 0);

  // WARNING NOTE: The value of 1.0 for the property
  // PARALLEL_RESAMPLING_OFFSET_FACTOR is only shown here
  // for illustrative purposes. In real life, you probably
  // do not want to use this value, as it can cause problems
  // in the physical embroidery.
  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 1.0;
  E.circle(125, 125, 200);

  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.5;
  E.circle(350, 125, 200);

  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.33333;
  E.circle(575, 125, 200);


  //-----------------------
  // Hatches have a stitch length of 40.
  E.hatchMode(PEmbroiderGraphics.PARALLEL);
  E.hatchAngleDeg(20.0); 
  E.hatchSpacing(2.5); 
  E.setStitch( 5, 40, 0);

  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 1.0;
  E.circle(125, 350, 200);

  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.5;
  E.circle(350, 350, 200);

  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.33333;
  E.circle(575, 350, 200);


  //-----------------------
  // Hatches have a noisy stitch length, of approximately 30.
  E.hatchMode(PEmbroiderGraphics.PARALLEL);
  E.hatchAngleDeg(20.0); 
  E.hatchSpacing(2.0); 
  E.setStitch(5, 30, 0.5);

  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 1.0;
  E.circle(125, 575, 200);

  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.5;
  E.circle(350, 575, 200);

  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.33333;
  E.circle(575, 575, 200);
  
 

  //-----------------------
  //E.optimize(); // slow, but good and important
  E.visualize();
  //E.endDraw(); // write out the file
  //save("PEmbroider_shape_hatching_3.png");
}



//--------------------------------------------
void draw() {
  ;
}

// Test program for the PEmbroider library for Processing:
// Different methods for filling (hatching) shapes with PEmbroider: 
// * PEmbroiderGraphics.PARALLEL
// * PEmbroiderGraphics.CONCENTRIC
// * PEmbroiderGraphics.SPIRAL


import processing.embroider.*;
import static processing.embroider.PEmbroiderGraphics.*; // PEmbroiderGraphics.PARALLEL -> PARALLEL

PEmbroiderGraphics E;

void setup() {
  noLoop(); 
  size (700, 475);
  E = new PEmbroiderGraphics(this, width, height);

  String outputFilePath = sketchPath("PEmbroider_shape_hatching_5.vp3");
  E.setPath(outputFilePath); 
  E.beginDraw(); 
  E.clear();
  E.strokeWeight(1); 
  E.fill(0, 0, 0); 
  E.noStroke(); 
  E.setStitch(3,40,0);
  
  E.hatchMode(SATIN);
  
  
  //-----------------------
  //All these shapes are filled with a SATIN hatch
  
  //the setStitch function behaves differently 
  //with SATIN and SPIRAL fills as stitch placement
  //is sample based.
  //Parameters operate as though:
  //setStitch(desiredStitchLength, maxStitchLength, noise);
  E.setStitch(10,20,0.5);
  E.hatchSpacing(3);
  E.circle( 125, 125, 200);

  E.setStitch(40,50,0.5);
  E.hatchSpacing(3);
  E.circle(350, 125, 200);

  E.setStitch(100,100,0.75);
  E.hatchAngle(radians(90));
  E.hatchSpacing(4);
  E.circle(575, 125, 200);


  E.hatchSpacing(3);
  E.setStitch(15,50,0.5);
  E.arc( 125, 350, 200,200, 0, PI*1.75, PIE);

  
  E.setStitch(60,60,0.8);
  E.hatchSpacing(2.5);
  E.rect(250, 250, 200, 200);

  E.setStitch(30,50,0.95);
  E.hatchAngle(radians(14));
  E.hatchSpacing(2);
  E.rect (475, 250, 200, 200);

  


  //-----------------------
  //E.optimize(); // slow but good and important
  E.visualize();
  //E.endDraw(); // write out the file
  //save("PEmbroider_shape_hatching_4.png");
}


//--------------------------------------------
void draw() {
  ;
}

// Test program for the PEmbroider library for Processing:

import processing.embroider.*;
PEmbroiderGraphics E;
PGraphics PG; 


void setup() {
  size(1000, 500); 
  noLoop(); 

  PG = createGraphics(500, 500);

  E = new PEmbroiderGraphics(this, 500, 500);
  E.setPath ( sketchPath("PEmbroider_shape_merging.vp3")); 

  renderRasterGraphics(); 
  generateEmbroideryFromRasterGraphics();

  // draw the raster graphics, for reference
  image(PG, 0, 0);

  pushMatrix(); 
  translate(500,0); 
  E.visualize();
  popMatrix(); 
  E.optimize(); // slow, but good and important
  // E.endDraw(); // write out the file
}


//--------------------------------------------
void generateEmbroideryFromRasterGraphics() {
  E.beginDraw(); 
  E.clear();
  E.fill(0,0,0);
  E.stroke(0); 

  E.HATCH_MODE = PEmbroiderGraphics.CONCENTRIC;
  E.HATCH_SPACING = 3;
  E.hatchRaster(PG, 0, 0);
}


//--------------------------------------------
void renderRasterGraphics() {
  PG.beginDraw();
  PG.background(0);

  PG.fill(255);
  PG.stroke(0);
  PG.strokeWeight(3);
  
  // Circle biting from a square
  PG.rect(50, 100, 100, 100);
  PG.circle(150, 100, 100);

  // Square biting from a circle
  PG.circle(400, 100, 100);
  PG.rect(300, 100, 100, 100);

  // Square and circle merged
  PG.noStroke();
  PG.rect(52, 302, 96, 96);
  PG.circle(152, 302, 96);

  // Merged shapes with holes
  PG.noStroke();
  PG.rect(250, 300, 150, 150);
  PG.circle(402, 302, 96);
  PG.fill(0); 
  PG.circle(405, 405, 40);
  PG.circle(300, 350, 40);

  PG.endDraw();
}


//--------------------------------------------
void draw() {
  ;
}

// Test program for the PEmbroider library for Processing:
// Basic shapes

import processing.embroider.*;
PEmbroiderGraphics E;


void setup() {
  //noLoop(); 
  size (900, 600);

  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("PEmbroider_shapes.vp3");
  E.setPath(outputFilePath); 

  E.ellipseMode(CORNER);

  E.beginDraw(); 
  E.clear();
  E.strokeWeight(1); 
  E.fill(0, 0, 0); 
  E.noStroke(); 

  E.hatchSpacing(5);
  E.hatchAngleDeg(50);
  E.hatchMode(PEmbroiderGraphics.SATIN);
  E.setStitch(2, 50, 0); 
  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = 0.33;

  //-----------------------
  // Standard shapes are supported
  E.circle (50, 50, 150);
  E.square(225, 50, 150); 
  E.rect (400, 50, 100, 150);
  E.rect (525, 50, 150, 150, 25); 
  E.rect (700, 50, 150, 150, 0, 0, 0, 50); 
  
  
  E.quad (50, 250, 200, 250, 170, 400, 50, 400);
  E.ellipse(210, 250, 200, 150);
  E.triangle (410, 400, 460, 250, 510, 400); 
  E.arc (525, 250, 150, 150, 0, PI*1.25, PIE); 
  E.arc (700, 250, 150, 150, 0, PI*1.25, CHORD); 

  //-----------------------
  // Arbitrary polygons are supported
  E.beginShape();
  E.vertex(50, 450);
  E.vertex(50, 575);
  E.vertex( 330, 575);
  E.vertex( 330, 500);
  E.vertex(200, 500);
  E.vertex(175, 425);

  E.endShape(CLOSE);

  //-----------------------
  // Shapes can mix straight and curved sides
  E.beginShape();
  E.vertex(365, 475);
  E.quadraticVertex(530, 430, 450, 500);
  E.quadraticVertex(400, 530, 560, 575);
  E.vertex(560, 430);
  E.vertex(360, 430);
  E.endShape(CLOSE);

  //-----------------------
  // Shapes can be "compound" and include holes, 
  // i.e. have multiple contours
  E.beginShape();
  E.vertex(600, 460);
  E.vertex(850, 430);
  E.vertex(800, 575);
  E.vertex(620, 575);
  
  E.beginContour();
  E.vertex(650, 520);
  E.vertex(710, 520);
  E.vertex(735, 505);
  E.vertex(690, 475);
  
  E.vertex(643, 475);
  
  
  
  
  E.endContour();
  
  E.endShape(CLOSE);


  //-----------------------
  //E.optimize(); // slow, but very good and very important
  //E.visualize();
  //E.endDraw(); // write out the file
  //save("PEmbroider_shapes.png");
}

void draw(){
  background(200);
  if (mousePressed){
    E.eraser(mouseX,mouseY,20);
  }
  E.visualize();
}

// Test program for the PEmbroider library for Processing:
// When a shape has a thick stroke around it: 
// Is the stroke inside, outside, or centered on the shape's contour?
// ALSO SEE: the PEmbroider_strokeLocation example.
//
// PEmbroider provides some constants for doing this, for example: 
// E.strokeLocation(CENTER); // or INSIDE or OUTSIDE
// It's also possible to use a float between -1 and 1: 
// E.strokeLocation(0.33); // Slightly outside of center.

// Import the PEmbroider library
import processing.embroider.*;

// The next 'import' line allows quick access to PEmbroider constants. 
// By including it, you can simply write things like E.hatchMode(PARALLEL);
// instead of the more verbose E.hatchMode(PEmbroiderGraphics.PARALLEL);
import static processing.embroider.PEmbroiderGraphics.*; // 

// Declaration of the PEmbroider object
PEmbroiderGraphics E;

//===============================================
void setup() {
  noLoop(); 
  size (1150, 475);
  E = new PEmbroiderGraphics(this, width, height);

  String embroideryFileType = ".vp3"; // or ".dst", ".pes", ".jef" etc. 
  String outputFilePath = sketchPath("PEmbroider_stroke_outlines" + embroideryFileType);
  E.setPath(outputFilePath); 
  E.beginDraw(); 
  E.clear();

  
  //-----------------------
  // Stroke properties
  E.strokeMode(E.TANGENT);
  E.strokeWeight(15);
  E.strokeSpacing(3);
  E.noFill();

  //-----------------
  // Outline is positioned OUTSIDE the bounds of the shapes
  // NOTE: This is equivalent to E.strokeLocation(1);
  E.strokeLocation(OUTSIDE); //same as above
  E.beginComposite();
  E.composite.rect(125,175,200,200);
  E.composite.circle(125,225,150);
  E.composite.triangle(375,250,250, 60,150, 250);
  E.endComposite();
   
  //-----------------
  // Outline is CENTERed on the bounds of the shapes
  // NOTE: This is equivalent to E.strokeLocation(0);
  E.strokeLocation(CENTER);  //same as above
  E.beginComposite();
  E.composite.rect(475,175,200,200);
  E.composite.circle(475,225,150);
  E.composite.triangle(725,250,600, 60,500, 250);
  E.endComposite();    
  
  //-----------------
  // Outline is positioned INSIDE the bounds of the shapes
  // NOTE: This is equivalent to E.strokeLocation(-1);
  E.strokeLocation(INSIDE);  //same as above
  E.beginComposite();
  E.composite.rect(825,175,200,200);
  E.composite.circle(825,225,150);
  E.composite.triangle(1075,250,950, 60,850, 250);
  E.endComposite();    
    
    
  //-----------------
  // All of these shapes are drawn on the pixel-canvas 
  // (not rendered into the embroidery), as a "debug view".
  // This lets you see the differences.
  noFill();
  strokeWeight(3);
  stroke(255,125,200);
  
  rect(125,175,200,200);
  circle(125,225,150);
  triangle(375,250,250, 60,150, 250);
  rect(475,175,200,200);
  circle(475,225,150);
  triangle(725,250,600, 60,500, 250);
  rect(825,175,200,200);
  circle(825,225,150);
  triangle(1075,250,950, 60,850, 250);
  
  //-----------------
  // Uncomment E.endDraw() below to actually save the file!
  E.optimize(); // Slow, but good and important
  E.visualize();
  // E.endDraw(); // write out the embroidery file
  
  
  //-----------------
  // Should we also save a pixel screenshot?
  boolean bAlsoSaveScreenshot = false; 
  if (bAlsoSaveScreenshot){
    save("PEmbroider_stroke_outlines.png");
  }
}

// Test program for the PEmbroider library for Processing:
// Different methods for filling (hatching) shapes with PEmbroider: 
// * PEmbroiderGraphics.PARALLEL
// * PEmbroiderGraphics.CONCENTRIC
// * PEmbroiderGraphics.SPIRAL


import processing.embroider.*;
import static processing.embroider.PEmbroiderGraphics.*; // PEmbroiderGraphics.PARALLEL -> PARALLEL

PEmbroiderGraphics E;

void setup() {
  noLoop(); 
  size (500, 500);
  E = new PEmbroiderGraphics(this, width, height);

  String outputFilePath = sketchPath("PEmbroider_stroke_outlines_2.vp3");
  E.setPath(outputFilePath); 
  E.beginDraw(); 
  E.clear();

  // ------------------------

  E.noStroke();
  //fill settings
  E.fill(0,0,0);
  E.hatchMode(E.CONCENTRIC);
  E.setStitch(5,20,0); 
  //cull settings
  E.CULL_SPACING = 5;
  
  E.beginCull();
  
  E.fill(255,0,0);
  E.circle(320,250,200);
  E.fill(0,255,0);
  E.circle(200,350,150);
  E.fill(0,0,255);
  E.circle(200,200,250);
  
  E.endCull();
    
    
    
  E.noFill();
  //stroke settings
  E.strokeMode(E.PERPENDICULAR);
  
  E.stroke(0);  
  E.strokeWeight(35);
  E.strokeLocation(OUTSIDE);
  E.strokeSpacing(3);
    
  E.beginComposite();
  E.composite.circle(320,250,200);
  E.composite.circle(200,350,150);
  E.composite.circle(200,200,250);
  E.endComposite(); 
  
  
  

   
  //-----------------------
  //E.optimize(); // slow but good and important
  E.visualize(true,false,false);
  //E.endDraw(); // write out the file
  //save("PEmbroider_stroke_outlines_2.png");
}

// Test program for the PEmbroider library for Processing:
// Basic shapes

import processing.embroider.*;
PEmbroiderGraphics E;


void setup() {
  noLoop(); 
  size (950, 950);
  
  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("PEmbroider_strokes.vp3");
  E.setPath(outputFilePath); 

  E.beginDraw(); 
  E.clear();
  E.CIRCLE_DETAIL = 60;
  E.setRenderOrder(PEmbroiderGraphics.FILL_OVER_STROKE);
  E.PARALLEL_RESAMPLING_OFFSET_FACTOR = .33;

  //-----------------------
  // Shapes can have 
  // (1) a stroke and no fill; 
  // (2) a fill and no stroke;
  // (3) both stroke and fill.
  E.hatchSpacing(2);
  
  E.noFill();
  E.stroke(0); 
  E.strokeWeight(1); 
  E.circle (125, 125, 200); // (1)
  
  E.fill(0);
  E.noStroke(); 
  E.strokeWeight(1); 
  E.circle (125, 350, 200); // (2)
  
  E.fill(0);
  E.stroke(0);
  E.strokeWeight(1); 
  E.circle (125, 570, 200); // (3)

  
  //-----------------------
  // In "PERPENDICULAR" mode, strokes are  
  // rendered with perpendicular stitches. 
  E.noFill();
  E.stroke(0); 
  E.strokeMode(E.PERPENDICULAR);
  E.setStitch(2,25,0);
  
  E.strokeWeight(8); 
  E.strokeSpacing(4);
  E.circle (340, 125, 200);

  E.strokeWeight(20); 
  E.strokeSpacing(4);
  E.circle (570, 125, 200);
  
  E.strokeWeight(20); 
  E.strokeSpacing(8);
  E.circle (800, 125, 200);
  
  
  //-----------------------
  // In "TANGENT" mode, strokes are  
  // rendered with concentric stitches.
  E.noFill();
  E.stroke(0); 
  E.strokeMode(E.TANGENT);
  
  E.strokeWeight(8); 
  E.strokeSpacing(4);
  E.circle (340, 350, 200);

  E.strokeWeight(20); 
  E.strokeSpacing(4);
  E.circle (570, 350, 200);
  
  E.strokeWeight(20); 
  E.strokeSpacing(8);
  E.circle (800, 350, 200);
  

  //-----------------------
  // Here's a complex polygon with
  // both a thick stroke and a fill. 
  E.strokeMode(E.PERPENDICULAR);
  E.stroke(0); 
  E.fill(0); 
  
  E.beginShape();
  E.strokeWeight(20); 
  E.strokeSpacing(4);
  E.vertex(250, 470);
  E.vertex(525, 550);
  E.vertex(900, 470); 
  E.vertex(900, 650); 
  E.vertex(250, 650); 
  E.endShape(CLOSE); 
  
  //-------------------------
  // Here are more strokes on rectangles.
  E.noFill();
  
  
  //"TANGENT" Strokes
  E.STROKE_MODE = PEmbroiderGraphics.TANGENT;
  E.strokeWeight(8); 
  E.strokeSpacing(2);
  E.rect(50, 700, 175,175);
  
  E.strokeWeight(15); 
  E.strokeSpacing(10);
  E.rect(275, 700, 175,175);
  
  //"PERPENDICULAR" Strokes
  E.strokeMode(E.PERPENDICULAR);
  E.strokeWeight(10); 
  E.strokeSpacing(4);
  E.rect(500, 700, 175,175);
  
  E.strokeSpacing(8);
  E.rect(725, 700, 175,175);
   
  //-----------------------
  //E.optimize(); // VERY SLOW, but important for file output!
  E.visualize();
  //E.endDraw(); // write out the embroidery file
  //save("PEmbroider_strokes.png"); //saves a png of design from canvas
}

// Test program for the PEmbroider library for Processing:
// strokeMode(E.ANGLED);

import processing.embroider.*;
PEmbroiderGraphics E;

void setup() {
  noLoop(); 
  size (1400, 500);
  E = new PEmbroiderGraphics(this, width, height);

  String outputFilePath = sketchPath("PEmbroider_stroke_outlines_3.vp3");
  E.setPath(outputFilePath); 
  E.beginDraw();

  background(200); 
  E.clear();

  E.noFill();
  E.stroke(0, 0, 0); 
  E.strokeWeight(44); 
  E.strokeSpacing(2.0);
  E.setStitch(5, 66, 0);
  E.PERPENDICULAR_STROKE_CAP_DENSITY_MULTIPLIER = 0.4;
  
  // These are the 3 options:
   //E.strokeMode(E.PERPENDICULAR);
  // E.strokeMode(E.TANGENT);
  E.strokeMode(E.ANGLED);

  float ay = 50; 
  int nCurves = 11;
  for (int i=0; i<nCurves; i++) {
    float ax = map(i, 0, (nCurves-1), 0+50, width-200-50);
    float sa = map(i, 0, (nCurves-1), 30, -30); 
    println(sa);
    E.strokeAngleDeg(sa);

    E.beginShape();
    E.vertex(ax, ay);
    E.quadraticVertex(ax+075, ay+025, ax+100, ay+200);
    E.quadraticVertex(ax+125, ay+375, ax+200, ay+400);
    E.endShape();
  }

  //-----------------------
  //E.optimize(); // slow but good and important
  E.visualize(true,false,false);//true, false, false);
  //E.endDraw(); // write out the file
  //save("PEmbroider_stroke_outlines_3.png");
}

// Test program for the PEmbroider library for Processing:
// Lines and curves

import processing.embroider.*;
PEmbroiderGraphics E;


void setup() {
  noLoop(); 
  size (800, 600);

  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("PEmbroider_lines_1.vp3");
  E.setPath(outputFilePath);
}

void draw() {
  background(220); 
  E.beginDraw(); 
  E.clear();
  E.noFill(); 
  
  
  //-----------------------
  E.strokeWeight(1); 
  E.ellipseMode(CENTER);
  for (int i=0; i<6; i++){
    float cx = map(i,0,5, 100,width-100);
    float cy = 100; 
    float minStitchLen = map(i,0,5, 5, 40);
    E.setStitch(minStitchLen, 20, 0.0);
    E.circle(cx,cy, 100); 
  }
  
  

  //-----------------------
  E.strokeWeight(1); 
  E.setStitch(10, 40, 0.0);

  E.beginShape(); 
  float cx = 125; 
  float cy = 400;
  float r = 40;
  for (int i=0; i<=360; i++) {
    float t = map(i, 0, 360, 0, TWO_PI);
    float x = cx + r*sin(t) + (r*1.33)*cos(2*t); 
    float y = cy + r*cos(t) + (r*1.33)*sin(2*t); 
    E.vertex (x, y);
  }
  E.endShape();
  
  
  //-----------------------
  E.setStitch(4, 20, 0.0);
  E.beginShape();
  float px = 550;
  float py = 400; 
  float t = 0; 
  float rr = 0.25;
  for (int i=0; i<150; i++) {
    t += 10.0; 
    E.vertex(px,py);
    px += i*rr*sin(radians(t)); 
    py += i*rr*cos(radians(t)); 
  }
  E.endShape();
  
  
  //E.strokeSpacing(2.0);
  //E.strokeMode(PEmbroiderGraphics.PERPENDICULAR); 

  //-----------------------
  // E.optimize(); // slow, but very good and important
  E.visualize();
  // E.endDraw(); // write out the file
  // save("Pembroider_lines_2.png");  //saves a png of design from canvas
}