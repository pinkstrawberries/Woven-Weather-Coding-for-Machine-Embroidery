refactor code

// Helper function to set stitch style based on the season
void setStitchForSeason(String season) {
    if (season.equals("Autumn")) {
        E.setStitch(5, 10, 0.5);
        E.hatchMode(PEmbroiderGraphics.PARALLEL);
        E.hatchAngleDeg(30); // angled offset it kind of looks like falling leaves
    } else if (season.equals("Winter")) {
        E.setStitch(5, 15, 0.3);
        E.hatchMode(PEmbroiderGraphics.SPIRAL); // swirling snowflake effect
    } else if (season.equals("Spring")) {
        E.setStitch(4, 12, 0.4);
        E.hatchMode(PEmbroiderGraphics.CONCENTRIC); // blooming flower effect
    } else if (season.equals("Summer")) {
        E.setStitch(6, 14, 0.3);
        E.hatchMode(PEmbroiderGraphics.SATIN); // sun ray impression
    }
}

// Helper function to set color based on the temperature range
void setColorForTemperature(float temperature) {
    if (temperature <= 7.5) {
        E.fill(810); // light lilac
    } else if (temperature <= 10) {
        E.fill(620); // magenta
    } else if (temperature <= 12.5) {
        E.fill(614); // purple
    } else if (temperature <= 15) {
        E.fill(405); // blue
    } else if (temperature <= 17.5) {
        E.fill(19); // sky blue
    } else if (temperature <= 20) {
        E.fill(534); // teal green
    } else if (temperature <= 22.5) {
        E.fill(509); // leaf green
    } else if (temperature <= 25) {
        E.fill(513); // lime green
    } else if (temperature <= 27.5) {
        E.fill(202); // lemon yellow
    } else if (temperature <= 30) {
        E.fill(208); // orange
    } else if (temperature <= 35) {
        E.fill(126); // pumpkin
    } else if (temperature <= 37.5) {
        E.fill(800); // red
    } else {
        E.fill(807); // carmine
    }
}


import processing.embroider.*;
import processing.data.JSONObject;
import processing.data.JSONArray;
PEmbroiderGraphics E;

float hexRadius = 200; // adjust the radius of hexagon (distance from center to any corner)
float borderThickness = 20; // adjust the thickness of the border hexagon

JSONObject temperatureData;

void setup() {
  size(1000, 1000); // this adjusts the canvas size to match the 4x4 inch embroidery hoop on the Brother SE425 Embroidery Machine
  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("Final_Jan_and_Feb.vp3"); //saves as a VP3 file
  String pesOutputFilePath = sketchPath("Final_Jan_and_Feb.pes"); //saves as a PES file, which is what is uploaded into the SE425
  E.setPath(outputFilePath);
  E.setPath(pesOutputFilePath); // save as PES file with the correct name

  // upload the temperature data from JSON file
  temperatureData = loadJSONObject("sydney_temperature_2023.json"); // data sourced from Visual Crossing Weather API

  E.beginDraw(); //sourced from PEmbroider library)
  E.clear();

  // draw the hexagons with temperatures from temperature data
  drawMonthlyHexagons("2023-01", 250, 250); // january (top left hexagon) (two hexagons stacked vertically on top of each other)
  drawMonthlyHexagons("2023-02", 700, 250); // february (top right hexagon) (two hexagons stacked vertically on top of each other)

// sourced from PEmbroider library
  E.optimize(); // slow but necessary for good output. if there is too much code then removing this line can make it run faster.
  E.endDraw(); // write the embroidery file
  E.visualize(); //too see the embroidery stitches and how they are arranged
}

// function which is used to draw hexagons with different temperature values for a given month in 2023
// method for temperature extraction and averaging based on Processing.org
void drawMonthlyHexagons(String monthPrefix, float cx, float cy) {
  // extract temperature data from JSON file
  JSONArray days = temperatureData.getJSONArray("days"); // extract the "days" array from the JSON object containing temperature data

float extremeLow = Float.MAX_VALUE; // used to find the lowest temperature of the month
float extremeHigh = Float.MIN_VALUE; // used to find the highest temperature of the month
float sumHigh = 0; // variable to combine the daily high temperatures for calculating the average highest temperature of the month
float sumLow = 0; // variable to combine the daily low temperatures for calculating the average lowest temperature of the month
int count = 0; // this is a counter to keep a record of the number of days processed in the month

// repeat over all days in the JSON array to find temperatures for the specified month that i want
for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i); // extract the current dayâ€™s JSON object
    String date = day.getString("datetime"); // get the date string in a "yyyy-MM-dd" format (another reminder im glad to not be in america)

    if (date.startsWith(monthPrefix)) { // check if the date actually belongs to the given month
        float tempMax = day.getFloat("tempmax"); // find out the maximum temperature for the day
        float tempMin = day.getFloat("tempmin"); // find out the minimum temperature for the day

        if (tempMax > extremeHigh) extremeHigh = tempMax; // update extremeHigh if the current day's maximum temperature is higher (conditional)
        if (tempMin < extremeLow) extremeLow = tempMin; // update extremeLow if the current day's minimum temperature is lower (conditional)

        sumHigh += tempMax; // add the current day's maximum highest temperature to the total sum for averaging
        sumLow += tempMin; // add the current day's minimum lowest temperature to the total sum for averaging
        count++; // increase the counter to keep track of how many days are processed
    }
}

float averageHigh = sumHigh / count; // calculate the average high temperature for the month
float averageLow = sumLow / count; // calculate the average low temperature for the month


  // draw the hexagons for the given month (extremes and averages)
  drawHexagonWithBorder(cx, cy, getSeason(monthPrefix), "extreme", extremeLow, extremeHigh); // extreme low and high
  drawHexagonWithBorder(cx, cy + 450, getSeason(monthPrefix), "average", averageLow, averageHigh); // average low and high
}

// this is a function that determines the season based on what month of the year it is
// I just assigned month-to-season mapping based on what normally happens in southern hemisphere 
String getSeason(String month) {
  switch(month) {
    case "2023-03":
    case "2023-04":
    case "2023-05":
      return "Autumn";
    case "2023-06":
    case "2023-07":
    case "2023-08":
      return "Winter";
    case "2023-09":
    case "2023-10":
    case "2023-11":
      return "Spring";
    case "2023-12":
    case "2023-01":
    case "2023-02":
      return "Summer";
    default:
      return "";
  }
}
 
 // Helper function to set stitch style based on the season
void setStitchForSeason(String season) {
    if (season.equals("Autumn")) {
        E.setStitch(5, 10, 0.5);
        E.hatchMode(PEmbroiderGraphics.PARALLEL);
        E.hatchAngleDeg(30); // angled offset it kind of looks like falling leaves
    } else if (season.equals("Winter")) {
        E.setStitch(5, 15, 0.3);
        E.hatchMode(PEmbroiderGraphics.SPIRAL); // swirling snowflake effect
    } else if (season.equals("Spring")) {
        E.setStitch(4, 12, 0.4);
        E.hatchMode(PEmbroiderGraphics.CONCENTRIC); // blooming flower effect
    } else if (season.equals("Summer")) {
        E.setStitch(6, 14, 0.3);
        E.hatchMode(PEmbroiderGraphics.SATIN); // sun ray impression
    }
}


// this is a function that draws a hexagon with a border around it, with special stitch styling based on the season
// the stitch styles and border patterns are based on source code found in the PEmbroidery library- i have just altered and manipulated them to my own design choices
  void drawHexagonWithBorder(float cx, float cy, String season, String type, float temperatureLow, float temperatureHigh) {
    // draw the border hexagon with lower temperatures
    E.noFill();
    E.stroke(0);
    E.strokeWeight(borderThickness);
    E.strokeMode(PEmbroiderGraphics.PERPENDICULAR);
    E.strokeSpacing(4);

    // Set stitch style for the border based on the season
    setStitchForSeason(season);
    drawHexagon(cx, cy, hexRadius + borderThickness / 2);

    // Set the color for the inner hexagon (using the higher temperature)
    float temperature = temperatureHigh;
    setColorForTemperature(temperature);

    // Draw the inner hexagon (center fill)
    E.noStroke();
    setStitchForSeason(season); // Set stitch style for the fill based on the season
    drawHexagon(cx, cy, hexRadius - borderThickness);
}
 
  drawHexagon(cx, cy, hexRadius + borderThickness / 2);

  // this is a function to set the colour based on temperature for the centre hexagon (using the higher temperature)
  // colour-coding for temperature inspired by various crocheted/knitted/hand-embroidered temperature blankets made for sydney (images in GitHub)
  // these colours and their values are based on the SimThread 63 Spools Colour Chart (also linked in GitHub)
void setColorForTemperature(float temperature) {
    if (temperature <= 7.5) {
        E.fill(810); // light lilac
    } else if (temperature <= 10) {
        E.fill(620); // magenta
    } else if (temperature <= 12.5) {
        E.fill(614); // purple
    } else if (temperature <= 15) {
        E.fill(405); // blue
    } else if (temperature <= 17.5) {
        E.fill(19); // sky blue
    } else if (temperature <= 20) {
        E.fill(534); // teal green
    } else if (temperature <= 22.5) {
        E.fill(509); // leaf green
    } else if (temperature <= 25) {
        E.fill(513); // lime green
    } else if (temperature <= 27.5) {
        E.fill(202); // lemon yellow
    } else if (temperature <= 30) {
        E.fill(208); // orange
    } else if (temperature <= 35) {
        E.fill(126); // pumpkin
    } else if (temperature <= 37.5) {
        E.fill(800); // red
    } else {
        E.fill(807); // carmine
    }
}


  drawHexagon(cx, cy, hexRadius - borderThickness);
}

// this is a function which is used to draw a hexagon, defining the vertices of the hexagon with trigonometric calculations 
// based on Processing.org Regular Polygon Examples
void drawHexagon(float cx, float cy, float radius) {
  float angleOffset = PI / 6; // offset to ensure flat sides are facing each other AND NOT THE POINTY SIDES
  E.beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = angleOffset + i * PI / 3;
    float x = cx + cos(angle) * radius;
    float y = cy + sin(angle) * radius;
    E.vertex(x, y);
  }
  E.endShape(CLOSE); // done!!! :D
}


You're definitely on the right track with this! Let me help you improve the placement of your newly created helper functions (setStitchForSeason() and setColorForTemperature()) and clarify how they should be integrated. You've added these functions correctly, but a few adjustments are needed to streamline the usage and remove redundant code.

Here's a summary of what needs to be improved:

Placement of Helper Functions: The helper functions (setStitchForSeason() and setColorForTemperature()) should be defined outside of other functions. This means they should be placed anywhere in the code, outside other functions, to be reusable throughout the program.

Refactoring drawHexagonWithBorder():

You have two drawHexagon() calls in drawHexagonWithBorder(). Remove the extra, misplaced calls.
You should only need to call setStitchForSeason() and setColorForTemperature() once within the drawHexagonWithBorder() function, in the correct sections (for the border and fill styles).
Avoid calling setStitchForSeason() again when setting the fill for the hexagon. The fill should have its own properties, and only call it if you want to repeat the same style.
Letâ€™s refactor the code based on these suggestions.

Revised Code
import processing.embroider.*;
import processing.data.JSONObject;
import processing.data.JSONArray;
PEmbroiderGraphics E;

float hexRadius = 200; // adjust the radius of hexagon (distance from center to any corner)
float borderThickness = 20; // adjust the thickness of the border hexagon

JSONObject temperatureData;

void setup() {
  size(1000, 1000); // this adjusts the canvas size to match the 4x4 inch embroidery hoop on the Brother SE425 Embroidery Machine
  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("Final_Jan_and_Feb.vp3"); // saves as a VP3 file
  String pesOutputFilePath = sketchPath("Final_Jan_and_Feb.pes"); // saves as a PES file, which is what is uploaded into the SE425
  E.setPath(outputFilePath);
  E.setPath(pesOutputFilePath); // save as PES file with the correct name

  // upload the temperature data from JSON file
  temperatureData = loadJSONObject("sydney_temperature_2023.json"); // data sourced from Visual Crossing Weather API

  E.beginDraw(); // sourced from PEmbroider library
  E.clear();

  // draw the hexagons with temperatures from temperature data
  drawMonthlyHexagons("2023-01", 250, 250); // January (top left hexagon)
  drawMonthlyHexagons("2023-02", 700, 250); // February (top right hexagon)

  // sourced from PEmbroider library
  E.optimize(); // slow but necessary for good output. if there is too much code then removing this line can make it run faster.
  E.endDraw(); // write the embroidery file
  E.visualize(); // to see the embroidery stitches and how they are arranged
}

// function which is used to draw hexagons with different temperature values for a given month in 2023
// method for temperature extraction and averaging based on Processing.org
void drawMonthlyHexagons(String monthPrefix, float cx, float cy) {
  // extract temperature data from JSON file
  JSONArray days = temperatureData.getJSONArray("days"); // extract the "days" array from the JSON object containing temperature data

  float extremeLow = Float.MAX_VALUE; // used to find the lowest temperature of the month
  float extremeHigh = Float.MIN_VALUE; // used to find the highest temperature of the month
  float sumHigh = 0; // variable to combine the daily high temperatures for calculating the average highest temperature of the month
  float sumLow = 0; // variable to combine the daily low temperatures for calculating the average lowest temperature of the month
  int count = 0; // this is a counter to keep a record of the number of days processed in the month

  // repeat over all days in the JSON array to find temperatures for the specified month that i want
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i); // extract the current dayâ€™s JSON object
    String date = day.getString("datetime"); // get the date string in a "yyyy-MM-dd" format

    if (date.startsWith(monthPrefix)) { // check if the date actually belongs to the given month
      float tempMax = day.getFloat("tempmax"); // find out the maximum temperature for the day
      float tempMin = day.getFloat("tempmin"); // find out the minimum temperature for the day

      if (tempMax > extremeHigh) extremeHigh = tempMax; // update extremeHigh if the current day's maximum temperature is higher (conditional)
      if (tempMin < extremeLow) extremeLow = tempMin; // update extremeLow if the current day's minimum temperature is lower (conditional)

      sumHigh += tempMax; // add the current day's maximum highest temperature to the total sum for averaging
      sumLow += tempMin; // add the current day's minimum lowest temperature to the total sum for averaging
      count++; // increase the counter to keep track of how many days are processed
    }
  }

  float averageHigh = sumHigh / count; // calculate the average high temperature for the month
  float averageLow = sumLow / count; // calculate the average low temperature for the month

  // draw the hexagons for the given month (extremes and averages)
  drawHexagonWithBorder(cx, cy, getSeason(monthPrefix), "extreme", extremeLow, extremeHigh); // extreme low and high
  drawHexagonWithBorder(cx, cy + 450, getSeason(monthPrefix), "average", averageLow, averageHigh); // average low and high
}

// Helper function to set stitch style based on the season
void setStitchForSeason(String season) {
  if (season.equals("Autumn")) {
    E.setStitch(5, 10, 0.5);
    E.hatchMode(PEmbroiderGraphics.PARALLEL);
    E.hatchAngleDeg(30); // angled offset it kind of looks like falling leaves
  } else if (season.equals("Winter")) {
    E.setStitch(5, 15, 0.3);
    E.hatchMode(PEmbroiderGraphics.SPIRAL); // swirling snowflake effect
  } else if (season.equals("Spring")) {
    E.setStitch(4, 12, 0.4);
    E.hatchMode(PEmbroiderGraphics.CONCENTRIC); // blooming flower effect
  } else if (season.equals("Summer")) {
    E.setStitch(6, 14, 0.3);
    E.hatchMode(PEmbroiderGraphics.SATIN); // sun ray impression
  }
}

// this is a function to set the color based on temperature for the center hexagon (using the higher temperature)
// color-coding for temperature inspired by various crocheted/knitted/hand-embroidered temperature blankets made for Sydney
// these colors and their values are based on the SimThread 63 Spools Colour Chart
void setColorForTemperature(float temperature) {
  if (temperature <= 7.5) {
    E.fill(810); // light lilac
  } else if (temperature <= 10) {
    E.fill(620); // magenta
  } else if (temperature <= 12.5) {
    E.fill(614); // purple
  } else if (temperature <= 15) {
    E.fill(405); // blue
  } else if (temperature <= 17.5) {
    E.fill(19); // sky blue
  } else if (temperature <= 20) {
    E.fill(534); // teal green
  } else if (temperature <= 22.5) {
    E.fill(509); // leaf green
  } else if (temperature <= 25) {
    E.fill(513); // lime green
  } else if (temperature <= 27.5) {
    E.fill(202); // lemon yellow
  } else if (temperature <= 30) {
    E.fill(208); // orange
  } else if (temperature <= 35) {
    E.fill(126); // pumpkin
  } else if (temperature <= 37.5) {
    E.fill(800); // red
  } else {
    E.fill(807); // carmine
  }
}

// this function draws a hexagon with a border around it, with special stitch styling based on the season
// the stitch styles and border patterns are based on source code found in the PEmbroidery library, altered for custom design choices
void drawHexagonWithBorder(float cx, float cy, String season, String type, float temperatureLow, float temperatureHigh) {
  // draw the border hexagon with lower temperatures
  E.noFill();
  E.stroke(0);
  E.strokeWeight(borderThickness);
  E.strokeMode(PEmbroiderGraphics.PERPENDICULAR);
  E.strokeSpacing(4);

  // Set stitch style for the border based on the season
  setStitchForSeason(season);
  drawHexagon(cx, cy, hexRadius + borderThickness / 2);

  // Set the color for the inner hexagon (using the higher temperature)
  setColorForTemperature(temperatureHigh);

  // Draw the inner hexagon (center fill)
  E.noStroke();
  drawHexagon(cx, cy, hexRadius - borderThickness);
}

// function used to draw a hexagon, defining the vertices of the hexagon using trigonometric calculations
// based on Processing.org Regular Polygon Examples
void drawHexagon(float cx, float cy, float radius) {
  float angleOffset = PI / 6; // offset to ensure flat sides are facing each other AND NOT THE POINTY SIDES
  E.beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = angleOffset + i * PI / 3;
    float x = cx + cos(angle) * radius;
    float y = cy + sin(angle) * radius;
    E.vertex(x, y);
  }
  E.endShape(CLOSE); // done!!! :D
}

Summary of Changes:
Helper Functions (setStitchForSeason() and setColorForTemperature()):
Defined clearly outside of other functions.
Called within drawHexagonWithBorder() to remove the repeated logic.
Removed unnecessary repeated calls to drawHexagon().
Cleaned up drawHexagonWithBorder() to simplify and make it DRY (Donâ€™t Repeat Yourself).
These changes improve code readability, make maintenance easier, and keep your functions focused on their specific purposes. Let me know if you have any further questions! ðŸ˜Š
Great question! The suggestion I made is about refactoring your code to reduce repetition and make it more manageable. Currently, you have multiple instances in the code where you're setting stitch styles and colors based on different conditions (e.g., different seasons or temperature ranges). This type of repeated code can make the program longer, harder to maintain, and more error-prone.

Refactoring means restructuring the code to be cleaner and more efficient without changing its behavior. Letâ€™s break this down into more detail.

DRY Principle
DRY stands for "Don't Repeat Yourself". Itâ€™s a fundamental concept in programming that encourages avoiding duplication. When we see repetitive patterns, we can refactor them into reusable functions. Doing so makes the code easier to maintain, reduces the risk of errors when updating the logic, and improves readability.

Repeated Code in Your Project
In your code, you have several places where you set stitch styles and fill colors, depending on the season or temperature range:

The stitch style is set differently for each season in both the border hexagon and the inner hexagon.
The fill color is set differently for the inner hexagon based on temperature ranges.
How to Refactor
To make the code DRY, you could refactor repeated pieces into separate functions. Hereâ€™s how:

Set Stitch for Season: Create a function that sets the stitch style based on the season. This function can be called whenever you need to set the stitch for a given season, reducing the need to repeat if-else logic.

Set Color for Temperature: Similarly, create a function that sets the color based on the temperature range.

Letâ€™s see how to implement these helper functions:

Example Refactored Code
java
Copy code
// Helper function to set stitch style based on the season
void setStitchForSeason(String season) {
    if (season.equals("Autumn")) {
        E.setStitch(5, 10, 0.5);
        E.hatchMode(PEmbroiderGraphics.PARALLEL);
        E.hatchAngleDeg(30); // angled offset it kind of looks like falling leaves
    } else if (season.equals("Winter")) {
        E.setStitch(5, 15, 0.3);
        E.hatchMode(PEmbroiderGraphics.SPIRAL); // swirling snowflake effect
    } else if (season.equals("Spring")) {
        E.setStitch(4, 12, 0.4);
        E.hatchMode(PEmbroiderGraphics.CONCENTRIC); // blooming flower effect
    } else if (season.equals("Summer")) {
        E.setStitch(6, 14, 0.3);
        E.hatchMode(PEmbroiderGraphics.SATIN); // sun ray impression
    }
}

// Helper function to set color based on the temperature range
void setColorForTemperature(float temperature) {
    if (temperature <= 7.5) {
        E.fill(810); // light lilac
    } else if (temperature <= 10) {
        E.fill(620); // magenta
    } else if (temperature <= 12.5) {
        E.fill(614); // purple
    } else if (temperature <= 15) {
        E.fill(405); // blue
    } else if (temperature <= 17.5) {
        E.fill(19); // sky blue
    } else if (temperature <= 20) {
        E.fill(534); // teal green
    } else if (temperature <= 22.5) {
        E.fill(509); // leaf green
    } else if (temperature <= 25) {
        E.fill(513); // lime green
    } else if (temperature <= 27.5) {
        E.fill(202); // lemon yellow
    } else if (temperature <= 30) {
        E.fill(208); // orange
    } else if (temperature <= 35) {
        E.fill(126); // pumpkin
    } else if (temperature <= 37.5) {
        E.fill(800); // red
    } else {
        E.fill(807); // carmine
    }
}
Using the Helper Functions
Once you've created these helper functions, you can replace the repeated code with simple function calls. Hereâ€™s how to update the drawHexagonWithBorder() function using the helper functions:

java
Copy code
void drawHexagonWithBorder(float cx, float cy, String season, String type, float temperatureLow, float temperatureHigh) {
    // draw the border hexagon with lower temperatures
    E.noFill();
    E.stroke(0);
    E.strokeWeight(borderThickness);
    E.strokeMode(PEmbroiderGraphics.PERPENDICULAR);
    E.strokeSpacing(4);

    // Set stitch style for the border based on the season
    setStitchForSeason(season);
    drawHexagon(cx, cy, hexRadius + borderThickness / 2);

    // Set the color for the inner hexagon (using the higher temperature)
    float temperature = temperatureHigh;
    setColorForTemperature(temperature);

    // Draw the inner hexagon (center fill)
    E.noStroke();
    setStitchForSeason(season); // Set stitch style for the fill based on the season
    drawHexagon(cx, cy, hexRadius - borderThickness);
}
Advantages of This Approach
Readability: Your main functions (drawHexagonWithBorder(), etc.) become easier to read since the logic is broken down into more manageable parts.
Maintainability: If you need to add new seasons or adjust the existing stitching or color logic, you only need to do it in one place instead of in multiple parts of the code.
Avoiding Errors: When repeated logic is updated in several places, there's always a risk of missing one, leading to inconsistent behavior. With helper functions, this risk is minimized.
Flexibility: In the future, if you want to add a new stitch style, all you need to do is add another condition to the helper function without modifying the rest of the code.
By refactoring the repeated code, you make it easier to maintain and extend, especially as you continue developing more designs or styles in the future.

Let me know if you need further assistance with refactoring the code or anything else!


import processing.embroider.*;
import processing.data.JSONObject;
import processing.data.JSONArray;
PEmbroiderGraphics E;

float hexRadius = 200; // adjust the radius of hexagon (distance from center to any corner)
float borderThickness = 20; // adjust the thickness of the border hexagon

JSONObject temperatureData;

void setup() {
  size(1000, 1000); // this adjusts the canvas size to match the 4x4 inch embroidery hoop on the Brother SE425 Embroidery Machine
  E = new PEmbroiderGraphics(this, width, height);
  String outputFilePath = sketchPath("Final_Jan_and_Feb.vp3"); // saves as a VP3 file
  String pesOutputFilePath = sketchPath("Final_Jan_and_Feb.pes"); // saves as a PES file, which is what is uploaded into the SE425
  E.setPath(outputFilePath);
  E.setPath(pesOutputFilePath); // save as PES file with the correct name

  // upload the temperature data from JSON file
  temperatureData = loadJSONObject("sydney_temperature_2023.json"); // data sourced from Visual Crossing Weather API

  E.beginDraw(); // sourced from PEmbroider library
  E.clear();

  // draw the hexagons with temperatures from temperature data
  drawMonthlyHexagons("2023-01", 250, 250); // January (top left hexagon)
  drawMonthlyHexagons("2023-02", 700, 250); // February (top right hexagon)

  // sourced from PEmbroider library
  E.optimize(); // slow but necessary for good output. if there is too much code then removing this line can make it run faster.
  E.endDraw(); // write the embroidery file
  E.visualize(); // to see the embroidery stitches and how they are arranged
}

// function that determines the season based on the given month
// this assigns month-to-season mapping based on the southern hemisphere
String getSeason(String month) {
  switch(month) {
    case "2023-03":
    case "2023-04":
    case "2023-05":
      return "Autumn";
    case "2023-06":
    case "2023-07":
    case "2023-08":
      return "Winter";
    case "2023-09":
    case "2023-10":
    case "2023-11":
      return "Spring";
    case "2023-12":
    case "2023-01":
    case "2023-02":
      return "Summer";
    default:
      return "";
  }
}

// function which is used to draw hexagons with different temperature values for a given month in 2023
void drawMonthlyHexagons(String monthPrefix, float cx, float cy) {
  // extract temperature data from JSON file
  JSONArray days = temperatureData.getJSONArray("days"); // extract the "days" array from the JSON object containing temperature data

  float extremeLow = Float.MAX_VALUE; // used to find the lowest temperature of the month
  float extremeHigh = Float.MIN_VALUE; // used to find the highest temperature of the month
  float sumHigh = 0; // variable to combine the daily high temperatures for calculating the average highest temperature of the month
  float sumLow = 0; // variable to combine the daily low temperatures for calculating the average lowest temperature of the month
  int count = 0; // this is a counter to keep a record of the number of days processed in the month

  // repeat over all days in the JSON array to find temperatures for the specified month that i want
  for (int i = 0; i < days.size(); i++) {
    JSONObject day = days.getJSONObject(i); // extract the current dayâ€™s JSON object
    String date = day.getString("datetime"); // get the date string in a "yyyy-MM-dd" format

    if (date.startsWith(monthPrefix)) { // check if the date actually belongs to the given month
      float tempMax = day.getFloat("tempmax"); // find out the maximum temperature for the day
      float tempMin = day.getFloat("tempmin"); // find out the minimum temperature for the day

      if (tempMax > extremeHigh) extremeHigh = tempMax; // update extremeHigh if the current day's maximum temperature is higher (conditional)
      if (tempMin < extremeLow) extremeLow = tempMin; // update extremeLow if the current day's minimum temperature is lower (conditional)

      sumHigh += tempMax; // add the current day's maximum highest temperature to the total sum for averaging
      sumLow += tempMin; // add the current day's minimum lowest temperature to the total sum for averaging
      count++; // increase the counter to keep track of how many days are processed
    }
  }

  float averageHigh = sumHigh / count; // calculate the average high temperature for the month
  float averageLow = sumLow / count; // calculate the average low temperature for the month

  // draw the hexagons for the given month (extremes and averages)
  drawHexagonWithBorder(cx, cy, getSeason(monthPrefix), "extreme", extremeLow, extremeHigh); // extreme low and high
  drawHexagonWithBorder(cx, cy + 450, getSeason(monthPrefix), "average", averageLow, averageHigh); // average low and high
}

// Helper function to set stitch style based on the season
void setStitchForSeason(String season) {
  if (season.equals("Autumn")) {
    E.setStitch(5, 10, 0.5);
    E.hatchMode(PEmbroiderGraphics.PARALLEL);
    E.hatchAngleDeg(30); // angled offset it kind of looks like falling leaves
  } else if (season.equals("Winter")) {
    E.setStitch(5, 15, 0.3);
    E.hatchMode(PEmbroiderGraphics.SPIRAL); // swirling snowflake effect
  } else if (season.equals("Spring")) {
    E.setStitch(4, 12, 0.4);
    E.hatchMode(PEmbroiderGraphics.CONCENTRIC); // blooming flower effect
  } else if (season.equals("Summer")) {
    E.setStitch(6, 14, 0.3);
    E.hatchMode(PEmbroiderGraphics.SATIN); // sun ray impression
  }
}

// function to set the color based on temperature for the center hexagon (using the higher temperature)
void setColorForTemperature(float temperature) {
  if (temperature <= 7.5) {
    E.fill(810); // light lilac
  } else if (temperature <= 10) {
    E.fill(620); // magenta
  } else if (temperature <= 12.5) {
    E.fill(614); // purple
  } else if (temperature <= 15) {
    E.fill(405); // blue
  } else if (temperature <= 17.5) {
    E.fill(19); // sky blue
  } else if (temperature <= 20) {
    E.fill(534); // teal green
  } else if (temperature <= 22.5) {
    E.fill(509); // leaf green
  } else if (temperature <= 25) {
    E.fill(513); // lime green
  } else if (temperature <= 27.5) {
    E.fill(202); // lemon yellow
  } else if (temperature <= 30) {
    E.fill(208); // orange
  } else if (temperature <= 35) {
    E.fill(126); // pumpkin
  } else if (temperature <= 37.5) {
    E.fill(800); // red
  } else {
    E.fill(807); // carmine
  }
}

// function to draw a hexagon with a border around it, with special stitch styling based on the season
void drawHexagonWithBorder(float cx, float cy, String season, String type, float temperatureLow, float temperatureHigh) {
  // draw the border hexagon with lower temperatures
  E.noFill();
  E.stroke(0);
  E.strokeWeight(borderThickness);
  E.strokeMode(PEmbroiderGraphics.PERPENDICULAR);
  E.strokeSpacing(4);

  // Set stitch style for the border based on the season
  setStitchForSeason(season);
  drawHexagon(cx, cy, hexRadius + borderThickness / 2);

  // Set the color for the inner hexagon (using the higher temperature)
  setColorForTemperature(temperatureHigh);

  // Draw the inner hexagon (center fill)
  E.noStroke();
  drawHexagon(cx, cy, hexRadius - borderThickness);
}

// function used to draw a hexagon, defining the vertices of the hexagon using trigonometric calculations
void drawHexagon(float cx, float cy, float radius) {
  float angleOffset = PI / 6; // offset to ensure flat sides are facing each other AND NOT THE POINTY SIDES
  E.beginShape();
  for (int i = 0; i < 6; i++) {
    float angle = angleOffset + i * PI / 3;
    float x = cx + cos(angle) * radius;
    float y = cy + sin(angle) * radius;
    E.vertex(x, y);
  }
  E.endShape(CLOSE); // done!!! :D
}


Summary of Changes
Moved getSeason() before the first call to it in the code to ensure it is recognized when called.
Removed misplaced drawHexagon() function calls.
Let me know if you have any questions or if there's anything else I can assist with!


You're right, and I deeply appreciate your patience in going through this. Letâ€™s explicitly clarify whatâ€™s happening for the January hexagonâ€™s border and center fill stitch styles. Below, I'll walk through the code segments and correct the approach regarding the DRY refactoring.

Border Stitch Style for January
In the function drawHexagonWithBorder(), the border stitch style is determined by the season. Since January is part of Summer, the border stitch style is defined as follows:

java
Copy code
void drawHexagonWithBorder(float cx, float cy, String season, String type, float temperatureLow, float temperatureHigh) {
  // Draw the border hexagon with lower temperatures
  E.noFill();
  E.stroke(0);
  E.strokeWeight(borderThickness);
  E.strokeMode(PEmbroiderGraphics.PERPENDICULAR);
  E.strokeSpacing(4);

  // Set stitch style for the border based on the season
  if (season.equals("Summer")) {
    E.setStitch(10, 20, 0.4);
    E.hatchMode(PEmbroiderGraphics.ZIGZAG); // zigzag stitch reminiscent of sun rays for Summer
  }
  drawHexagon(cx, cy, hexRadius + borderThickness / 2);
For January (part of Summer):
Border Stitch:
E.setStitch(10, 20, 0.4);
E.hatchMode(PEmbroiderGraphics.ZIGZAG);
Center Fill Stitch Style for January
The center fill stitch style is set separately after the border is drawn:

java
Copy code
  // Draw the inner hexagon (center fill)
  E.noStroke();
  if (season.equals("Summer")) {
    E.setStitch(6, 14, 0.3);
    E.hatchMode(PEmbroiderGraphics.SATIN); // satin stitch for Summer center
  }
  drawHexagon(cx, cy, hexRadius - borderThickness);
For January (part of Summer):
Center Fill Stitch:
E.setStitch(6, 14, 0.3);
E.hatchMode(PEmbroiderGraphics.SATIN);
The Issue with DRY Refactoring
The earlier attempt to DRY the code using a single helper function (setStitchForSeason()) incorrectly combined the border and center fill stitch logic. This led to unintended results because:

The border and center fill stitches should be different for visual contrast.
The refactored function (setStitchForSeason()) applied one style to both, which made the code lose its distinction between border and center fill stitches.
The original implementation allowed for different stitch styles for the border and the center fill by manually setting them separately, and the refactoring ignored that.

Should You Refactor the Code?
Refactoring can be beneficial for readability and maintenance. However, when elements are context-specific (like the different stitch styles for borders and centers), it might not always be a good idea to generalize them too much.

In this case, given that the border and center fill have different requirements, the original approach (separating them out) is actually clearer and better suited for your needs.

Corrected Approach
To ensure both border and center have unique stitches, we can:

Keep the stitch styles separate as you did originally.
Use more targeted helper functions if you think it will improve readability, but always make sure to differentiate between border and center.
If we still want a level of refactoring while keeping the styles distinct, we could introduce two separate functions:

setBorderStitchForSeason(season): Sets the stitch style for the border based on the season.
setCenterStitchForSeason(season): Sets the stitch style for the center based on the season.
This way, you keep the readability and modularity while ensuring the styles stay distinct.

Example: Separate Functions for Border and Center
java
Copy code
void setBorderStitchForSeason(String season) {
  if (season.equals("Summer")) {
    E.setStitch(10, 20, 0.4);
    E.hatchMode(PEmbroiderGraphics.ZIGZAG); // zigzag for border
  }
  // Add cases for other seasons...
}

void setCenterStitchForSeason(String season) {
  if (season.equals("Summer")) {
    E.setStitch(6, 14, 0.3);
    E.hatchMode(PEmbroiderGraphics.SATIN); // satin for center
  }
  // Add cases for other seasons...
}
Then, in drawHexagonWithBorder(), call them like this:

java
Copy code
// Set the border stitch style
setBorderStitchForSeason(season);
drawHexagon(cx, cy, hexRadius + borderThickness / 2);

// Set the center fill stitch style
E.noStroke();
setCenterStitchForSeason(season);
drawHexagon(cx, cy, hexRadius - borderThickness);
Summary
The original approach was correct in separating the border and center fill stitches.
The previous refactoring attempt incorrectly combined the logic, which is why the distinction between border and center styles was lost.
Itâ€™s best to either keep the original or use separate helper functions for border and center, as outlined above.
I understand the frustration that this mistake caused, and I appreciate your patience in reviewing the details. Thank you for pointing it out, and I hope this corrected approach helps maintain both clarity and functionality in your code.